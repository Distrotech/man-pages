.\" Page by b.hubert
.\" and Copyright (C) 2015, Thomas Gleixner <tglx@linutronix.de>
.\" and Copyright (C) 2015, Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(FREELY_REDISTRIBUTABLE)
.\" may be freely modified and distributed
.\" %%%LICENSE_END
.\"
.\" Niki A. Rahimi (LTC Security Development, narahimi@us.ibm.com)
.\" added ERRORS section.
.\"
.\" Modified 2004-06-17 mtk
.\" Modified 2004-10-07 aeb, added FUTEX_REQUEUE, FUTEX_CMP_REQUEUE
.\"
.\" FIXME
.\" 2.6.18 adds (Ingo Molnar) priority inheritance support:
.\" FUTEX_LOCK_PI, FUTEX_UNLOCK_PI, and FUTEX_TRYLOCK_PI.  These need
.\" to be documented in the manual page.  Probably there is sufficient
.\" material in the kernel source file Documentation/pi-futex.txt.
.\"	commit c87e2837be82df479a6bae9f155c43516d2feebc
.\"	Author: Ingo Molnar <mingo@elte.hu>
.\"	Date:   Tue Jun 27 02:54:58 2006 -0700
.\"
.\"	commit e2970f2fb6950183a34e8545faa093eb49d186e1
.\"	Author: Ingo Molnar <mingo@elte.hu>
.\"	Date:   Tue Jun 27 02:54:47 2006 -0700
.\"
.\"	See Documentation/pi-futex.txt
.\"
.\" FIXME
.\" 2.6.25 adds FUTEX_WAKE_BITSET, FUTEX_WAIT_BITSET
.\"	commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
.\"	Author: Thomas Gleixner <tglx@linutronix.de>
.\"	Date:   Fri Feb 1 17:45:14 2008 +0100
.\"
.\" FIXME
.\" 2.6.31 adds FUTEX_WAIT_REQUEUE_PI, FUTEX_CMP_REQUEUE_PI
.\"	commit 52400ba946759af28442dee6265c5c0180ac7122
.\"	Author: Darren Hart <dvhltc@us.ibm.com>
.\"	Date:   Fri Apr 3 13:40:49 2009 -0700
.\"
.\"	commit ba9c22f2c01cf5c88beed5a6b9e07d42e10bd358
.\"	Author: Darren Hart <dvhltc@us.ibm.com>
.\"	Date:   Mon Apr 20 22:22:22 2009 -0700
.\"
.\"	See Documentation/futex-requeue-pi.txt
.\"
.TH FUTEX 2 2014-05-21 "Linux" "Linux Programmer's Manual"
.SH NAME
futex \- fast user-space locking
.SH SYNOPSIS
.nf
.sp
.B "#include <linux/futex.h>"
.B "#include <sys/time.h>"
.sp
.BI "int futex(int *" uaddr ", int " futex_op ", int " val ,
.BI "          const struct timespec *" timeout ,
.BI "          int *" uaddr2 ", int " val3 );
.\" int *? void *? u32 *?
.fi

.IR Note :
There is no glibc wrapper for this system call; see NOTES.
.SH DESCRIPTION
.PP
The
.BR futex ()
system call provides a method for
a program to wait for a value at a given address to change, and a
method to wake up anyone waiting on a particular address (while the
addresses for the same memory in separate processes may not be
equal, the kernel maps them internally so the same memory mapped in
different locations will correspond for
.BR futex ()
calls).
This system call is typically used to
implement the contended case of a lock in shared memory, as
described in
.BR futex (7).
.PP
When a futex operation did not finish uncontended in user space, a
.BR futex ()
call needs to be made to the kernel to arbitrate.
Arbitration can either mean putting the calling
process to sleep or, conversely, waking a waiting process.
.PP
Callers of
.BR futex ()
are expected to adhere to the semantics described in
.BR futex (7).
As these
semantics involve writing nonportable assembly instructions, this in turn
probably means that most users will in fact be library authors and not
general application developers.
.PP
The
.I uaddr
argument points to an integer which stores the counter (futex).
On all platforms, futexes are four-byte integers that
must be aligned on a four-byte boundary.
The operation to perform on the futex is specified in the
.I futex_op
argument;
.IR val
is a value whose meaning and purpose depends on
.IR futex_op .

The remaining arguments
.RI ( timeout ,
.IR uaddr2 ,
and
.IR val3 )
are required only for certain of the futex operations described below.
Where one of these arguments is not required, it is ignored.
For several blocking operations, the
.I timeout
argument is a pointer to a
.IR timespec
structure that specifies a timeout for the operation.
However,  notwithstanding the prototype shown above, for some operations,
this argument is instead a four-byte integer whose meaning
is determined by the operation.
Where it is required,
.IR uaddr2
is a pointer to a second futex that is employed by the operation.
The interpretation of the final integer argument,
.IR val3 ,
depends on the operation.

The
.I futex_op
argument consists of two parts:
a command that specifies the operation to be performed,
bit-wise ORed with zero or or more options that
modify the behaviour of the operation.
The options that may be included in
.I futex_op
are as follows:
.TP
.BR FUTEX_PRIVATE_FLAG " (since Linux 2.6.22)"
.\" commit 34f01cc1f512fa783302982776895c73714ebbc2
This option bit can be employed with all futex operations.
It tells the kernel that the futex is process private and not shared
with another process.
This allows the kernel to choose the fast path for validating
the user-space address and avoids expensive VMA lookups,
taking reference counts on file backing store, and so on.

As a convenience,
.IR <linux/futex.h>
defines a set of constants with the suffix
.BR _PRIVATE
that are equivalents of all of the operations listed below,
.\" except the obsolete FUTEX_FD for which the "private" flag was
.\" meaningless
but with the
.BR FUTEX_PRIVATE_FLAG
ORed into the constant value.
Thus, there are
.BR FUTEX_WAIT_PRIVATE ,
.BR FUTEX_WAKE_PRIVATE ,
and so on.
.TP
.BR FUTEX_CLOCK_REALTIME " (since Linux 2.6.28)"
.\" commit 1acdac104668a0834cfa267de9946fac7764d486
This option bit can be employed only with the
.BR FUTEX_WAIT_BITSET
and
.BR FUTEX_WAIT_REQUEUE_PI
operations (described below).

If this option is set,
the kernel treats the user space supplied timeout as an absolute
time based on
.BR CLOCK_REALTIME .

If this option is not set,
the kernel treats the user space supplied timeout as relative time,
.\" FIXME I added CLOCK_MONOTONIC here. Is it correct?
measured against the
.BR CLOCK_MONOTONIC
clock.
.PP
The operation specified in
.I futex_op
is one of the following:
.TP
.BR FUTEX_WAIT " (since Linux 2.6.0)"
.\" Strictly speaking, since some time in 2.5.x
This operation tests that the value at the
location pointed to by the futex address
.I uaddr
still contains the value
.IR val ,
and then sleeps awaiting
.B FUTEX_WAKE
on the futex address.
The test and sleep steps are performed atomically.
If the futex value does not match
.IR val ,
then the call fails immediately with the error
.BR EWOULDBLOCK .
.\" FIXME I added the following sentence. Please confirm that it is correct.
The purpose of the test step is to detect races where
another process changes that value of the futex between
the time it was last checked and the time of the
.BR FUTEX_WAIT
oepration.


If the
.I timeout
argument is non-NULL, its contents specify a relative timeout for the wait
.\" FIXME I added CLOCK_MONOTONIC here. Is it correct?
measured according to the
.BR CLOCK_MONOTONIC
clock.
(This interval will be rounded up to the system clock granularity,
and kernel scheduling delays mean that the
blocking interval may overrun by a small amount.)
If
.I timeout
is NULL, the call blocks indefinitely.

The arguments
.I uaddr2
and
.I val3
are ignored.

For
.BR futex (7),
this call is executed if decrementing the count gave a negative value
(indicating contention), and will sleep until another process releases
the futex and executes the
.B FUTEX_WAKE
operation.
.TP
.BR FUTEX_WAIT_BITSET " (since Linux 2.6.25)"
.\" commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
.\" FIXME TO complete
.\"
.\" FIXME Employs 'timeout' argument
.\"
[As yet undocumented]
.TP
.BR FUTEX_WAKE " (since Linux 2.6.0)"
.\" Strictly speaking, since Linux 2.5.x
This operation wakes at most
.I val
processes waiting (i.e., inside
.BR FUTEX_WAIT )
on the futex at the address
.IR uaddr .
Most commonly,
.I val
is specified as either 1 (wake up a single waiter) or
.BR INT_MAX
(wake up all waiters).
.\" FIXME Please confirm that the following is correct:
No guarantee is provided about which waiters are awoken
(e.g., a waiter with a higher scheduling priority is not guaranteed
to be awoken in preference to a waiter with a lower priority).

The arguments
.IR timeout ,
.I uaddr2
and
.I val3
are ignored.

For
.BR futex (7),
this is executed if incrementing
the count showed that there were waiters, once the futex value has been set
to 1 (indicating that it is available).
.\"
.\" FIXME I added some FUTEX_WAKE_OP text, and I'd be happy if someone
.\"       checked it.
.TP
.BR FUTEX_WAKE_OP " (since Linux 2.6.14)"
.\" commit 4732efbeb997189d9f9b04708dc26bf8613ed721
.\"	Author: Jakub Jelinek <jakub@redhat.com>
.\"	Date:   Tue Sep 6 15:16:25 2005 -0700
This operation was added to support some user-space use cases
where more than one futex must be handled at the same time.
The most notable example is the implementation of
.BR pthread_cond_signal (3),
which requires operations on two futexes,
the one used to implement the mutex and the one used in the implementation
of the wait queue associated with the condition variable.
.BR FUTEX_WAKE_OP
allows such cases to be implemented without leading to
high rates of contention and context switching.

The
.BR FUTEX_WAIT_OP
operation is equivalent to atomically executing the following code:

.in +4n
.nf
int oldval = *(int *) uaddr2;
*(int *) uaddr2 = oldval \fIop\fP \fIoparg\fP;
futex(uaddr, FUTEX_WAKE, val, 0, 0, 0);
if (oldval \fIcmp\fP \fIcmparg\fP)
    futex(uaddr2, FUTEX_WAKE, nr_wake2, 0, 0, 0);
.fi
.in

In other words,
.BR FUTEX_WAIT_OP
does the following:
.RS
.IP * 3
saves the original value of the futex at
.IR uaddr2 ;
.IP *
performs an operation to modify the value of the futex at
.IR uaddr2 ;
.IP *
wakes up a maximum of
.I val
waiters on the futex
.IR uaddr ;
and
.IP *
dependent on the results of a test of the original value of the futex at
.IR uaddr2 ,
wakes up a maximum of
.I nr_wake2
waiters on the futex
.IR uaddr2 .
.RE
.IP
The
.I nr_wake2
value is actually the
.BR futex ()
.I timeout
argument (ab)used to specify how many of the waiters on the futex at
.IR uaddr2
are to be woken up;
the kernel casts the
.I timeout
value to
.IR u32 .

The operation and comparison that are to be performed are encoded
in the bits of the argument
.IR val3 .
Pictorially, the encoding is:

.in +4n
.nf
        +-----+-----+---------------+---------------+
        | op  | cmp |     oparg     |    cmparg     |
        +-----+-----+---------------+---------------+
# of bits: 4     4          12              12

.fi
.in

Expressed in code, the encoding is:

.in +4n
.nf
#define FUTEX_OP(op, oparg, cmp, cmparg) \\
                (((op & 0xf) << 28) | \\
                ((cmp & 0xf) << 24) | \\
                ((oparg & 0xfff) << 12) | \\
                (cmparg & 0xfff))
.fi
.in

In the above,
.I op
and
.I cmp
are each one of the codes listed below.
The
.I oparg
and
.I cmparg
components are literal numeric values, except as noted below.

The
.I op
component has one of the following values:

.in +4n
.nf
FUTEX_OP_SET        0  /* uaddr2 = oparg; */
FUTEX_OP_ADD        1  /* uaddr2 += oparg; */
FUTEX_OP_OR         2  /* uaddr2 |= oparg; */
FUTEX_OP_ANDN       3  /* uaddr2 &= ~oparg; */
FUTEX_OP_XOR        4  /* uaddr2 ^= oparg; */
.fi
.in

In addition, bit-wise ORing the following value into
.I op
causes
.IR "(1\ <<\ oparg)"
to be used as the operand:

.in +4n
.nf
FUTEX_OP_ARG_SHIFT  8  /* Use (1 << oparg) as operand */
.fi
.in

The
.I cmp
field is one of the following:

.in +4n
.nf
FUTEX_OP_CMP_EQ     0  /* if (oldval == cmparg) wake */
FUTEX_OP_CMP_NE     1  /* if (oldval != cmparg) wake */
FUTEX_OP_CMP_LT     2  /* if (oldval < cmparg) wake */
FUTEX_OP_CMP_LE     3  /* if (oldval <= cmparg) wake */
FUTEX_OP_CMP_GT     4  /* if (oldval > cmparg) wake */
FUTEX_OP_CMP_GE     5  /* if (oldval >= cmparg) wake */
.fi
.in

The return value of
.BR FUTEX_WAKE_OP
is the sum of the number of waiters woken on the futex
.IR uaddr
plus the number of waiters woken on the futex
.IR uaddr2 .
.TP
.BR FUTEX_WAKE_BITSET " (since Linux 2.6.25)"
.\" commit cd689985cf49f6ff5c8eddc48d98b9d581d9475d
.\" FIXME TO complete
[As yet undocumented]
.TP
.BR FUTEX_LOCK_PI " (since Linux 2.6.18)"
.\" commit c87e2837be82df479a6bae9f155c43516d2feebc
.\" FIXME to complete
.\"
.\" FIXME Employs 'timeout' argument
.\"
[As yet undocumented]
.TP
.BR FUTEX_UNLOCK_PI " (since Linux 2.6.18)"
.\" commit c87e2837be82df479a6bae9f155c43516d2feebc
.\" FIXME to complete
[As yet undocumented]
.TP
.BR FUTEX_TRYLOCK_PI " (since Linux 2.6.18)"
.\" commit c87e2837be82df479a6bae9f155c43516d2feebc
.\" FIXME to complete
[As yet undocumented]
.TP
.BR FUTEX_FD " (from Linux 2.6.0 up to and including Linux 2.6.25)"
.\" Strictly speaking, from Linux 2.5.x to 2.6.25
This operation creates a file descriptor that is associated with the futex at
.IR uaddr .
.\" , suitable for .BR poll (2).
The calling process must close the returned file descriptor after use.
When another process performs a
.BR FUTEX_WAKE
on the futex, the file descriptor indicates as being readable with
.BR select (2),
.BR poll (2),
and
.BR epoll (7)

The file descriptor can be used to obtain asynchronous notifications:
if
.I val
is nonzero, then when another process executes a
.BR FUTEX_WAKE ,
the caller will receive the signal number that was passed in
.IR val .

The arguments
.IR timeout ,
.I uaddr2
and
.I val3
are ignored.

To prevent race conditions, the caller should test if the futex has
been upped after
.B FUTEX_FD
returns.

Because it was inherently racy,
.B FUTEX_FD
has been removed
.\" commit 82af7aca56c67061420d618cc5a30f0fd4106b80
from Linux 2.6.26 onward.
.TP
.BR FUTEX_REQUEUE " (since Linux 2.6.0)"
.\" Strictly speaking: from Linux 2.5.70
.\"
.\" FIXME I added this warning. Okay?
.IR "Avoid using this operation" .
It is broken (unavoidably racy) for its intended purpose.
Use
.BR FUTEX_CMP_REQUEUE
instead.

This operation performs the same task as
.BR FUTEX_CMP_REQUEUE ,
except that no check is made using the value in
.IR  val3 .
(The argument
.I val3
is ignored.)
.TP
.BR FUTEX_CMP_REQUEUE " (since Linux 2.6.7)"
This operation was added as a replacement for the earlier
.BR FUTEX_REQUEUE ,
because that operation was racy for its intended use.

As with
.BR FUTEX_REQUEUE ,
the
.BR FUTEX_CMP_REQUEUE
operation is used to avoid a "thundering herd" effect when
.B FUTEX_WAKE
is used and all processes woken up need to acquire another futex.
It differs from
.BR FUTEX_REQUEUE
in that it first checks whether the location
.I uaddr
still contains the value
.IR val3 .
If not, the operation fails with the error
.BR EAGAIN .
.\" FIXME I added the following sentence on rational for FUTEX_CMP_REQUEUE.
.\"       Is it correct? SHould it be expanded?
This additional feature of
.BR FUTEX_CMP_REQUEUE
can be used by the caller to (atomically) detect changes
in the value of the target futex at
.IR uaddr2 .

The operation wakes up a maximum of
.I val
waiters that are waiting on the futex at
.IR uaddr .
If there are more than
.I val
waiters, then the remaining waiters are removed
from the wait queue of the source futex at
.I uaddr
and added to the wait queue of the target futex at
.IR uaddr2 .
The
.I timeout
argument is (ab)used to specify a cap on the number of waiters
that are requeued to the futex at
.IR uaddr2 ;
the kernel casts the
.I timeout
value to
.IR u32 .

.\" FIXME Please review the following new paragraph to see if it is
.\"       accurate.
Typical values to specify for
.I val
are 0 or or 1.
(Specifying
.BR INT_MAX
is not useful, because it would make the
.BR FUTEX_CMP_REQUEUE
operation equivalent to
.BR FUTEX_WAKE .)
The cap value specified via the (abused)
.I timeout
argument is typically either 1 or
.BR INT_MAX .
(Specifying the argument as 0 is not useful, because it would make the
.BR FUTEX_CMP_REQUEUE
operation equivalent to
.BR FUTEX_WAIT .)
.TP
.BR FUTEX_CMP_REQUEUE_PI " (since Linux 2.6.31)"
.\" commit 52400ba946759af28442dee6265c5c0180ac7122
.\" FIXME to complete
[As yet undocumented]
.TP
.BR FUTEX_WAIT_REQUEUE_PI " (since Linux 2.6.31)"
.\" commit 52400ba946759af28442dee6265c5c0180ac7122
.\" FIXME to complete
[As yet undocumented]
.SH RETURN VALUE
.PP
In the event of an error, all operations return \-1, and set
.I errno
to indicate the error.
The return value on success depends on the operation,
as described in the following list:
.TP
.B FUTEX_WAIT
Returns 0 if the process was woken by a
.B FUTEX_WAKE
call.
See ERRORS for the various possible error returns.
.TP
.B FUTEX_WAKE
Returns the number of processes woken up.
.TP
.B FUTEX_FD
Returns the new file descriptor associated with the futex.
.TP
.B FUTEX_REQUEUE
Returns the number of processes woken up.
.TP
.B FUTEX_CMP_REQUEUE
Returns the total number of processes woken up or requeued to the futex at
.IR uaddr2 .
If this value is greater than
.IR val ,
then difference is the number of waiters requeued to the futex at
.IR uaddr2 .
.\"
.\" FIXME Add success returns for other operations
.SH ERRORS
.TP
.B EACCES
No read access to futex memory.
.TP
.B EAGAIN
.B FUTEX_CMP_REQUEUE
detected that the value pointed to by
.I uaddr
is not equal to the expected value
.IR val3 .
.\" FIXME: Is the following sentence correct?
(This probably indicates a race;
use the safe
.B FUTEX_WAKE
now.)
.TP
.B EFAULT
A required pointer argument (i.e.,
.IR uaddr ,
.IR uaddr2 ,
or
.IR timeout )
did not point to a valid user-space address.
.TP
.B EINTR
A
.B FUTEX_WAIT
or
.B FUTEX_WAIT_BITSET
operation was interrupted by a signal (see
.BR signal (7))
or a spurious wakeup.
.TP
.B EINVAL
The operation in
.IR futex_op
is one of those that employs a timeout, but the supplied
.I timeout
argument was invalid
.RI ( tv_sec
was less than zero, or
.IR tv_nsec
was not less than 1000,000,000).
.TP
.B EINVAL
The operation specified in
.BR futex_op
employs one or both of the pointers
.I uaddr
and
.IR uaddr2 ,
but one of these does not point to a valid object\(emthat is,
the address is not four-byte-aligned.
.TP
.B EINVAL
.RB ( FUTEX_WAKE ,
.BR FUTEX_REQUEUE ,
.BR FUTEX_CMP_REQUEUE )
The kernel detected an inconsistency between the user-space state at
.I uaddr
and the kernel state\(emthat is, it detected a waiter which waits in
.BR FUTEX_LOCK_PI .
.TP
.B EINVAL
.RB ( FUTEX_REQUEUE )
.\" FIXME tglx suggested adding this, but does this error really
.\"       occur for FUTEX_REQUEUE?
.I uaddr
equals
.IR uaddr2
(i.e., an attempt was made to requeue to the same futex).
.TP
.B EINVAL
.RB ( FUTEX_WAKE_OP )
The kernel detected an inconsistency between the user-space state at
.I uaddr
and the kernel state; that is, it detected a waiter which waits in
.B FUTEX_LOCK_PI
on
.IR uaddr .
.TP
.BR EINVAL
.RB ( FUTEX_FD )
The signal number supplied in
.I val
is invalid.
.TP
.B EINVAL
Invalid argument.
.TP
.B ENFILE
.RB ( FUTEX_FD )
The system limit on the total number of open files has been reached.
.TP
.B ENOSYS
Invalid operation specified in
.IR futex_op .
.TP
.B ENOSYS
The
.BR FUTEX_CLOCK_REALTIME
option was specified in
.IR futex_op ,
but the accompanying operation was neither
.BR FUTEX_WAIT_BITSET
nor
.BR FUTEX_WAIT_REQUEUE_PI .
.TP
.B ETIMEDOUT
The operation in
.IR futex_op
employed the timeout specified in
.IR timeout ,
and the timeout expired before the operation completed.
.TP
.B EWOULDBLOCK
.RB ( FUTEX_WAIT )
The value pointed to by
.I uaddr
was not equal to the expected value
.I val
at the time of the call.
.SH VERSIONS
.PP
Futexes were first made available in a stable kernel release
with Linux 2.6.0.

Initial futex support was merged in Linux 2.5.7 but with different semantics
from what was described above.
A four-argument system call with the semantics
described in this page was introduced in Linux 2.5.40.
In Linux 2.5.70, one argument
was added.
In Linux 2.6.7, a sixth argument was added\(emmessy, especially
on the s390 architecture.
.SH CONFORMING TO
This system call is Linux-specific.
.SH NOTES
.PP
To reiterate, bare futexes are not intended as an easy-to-use abstraction
for end-users.
(There is no wrapper function for this system call in glibc.)
Implementors are expected to be assembly literate and to have
read the sources of the futex user-space library referenced below.
.\" .SH "AUTHORS"
.\" .PP
.\" Futexes were designed and worked on by
.\" Hubertus Franke (IBM Thomas J. Watson Research Center),
.\" Matthew Kirkwood, Ingo Molnar (Red Hat)
.\" and Rusty Russell (IBM Linux Technology Center).
.\" This page written by bert hubert.
.SH SEE ALSO
.BR restart_syscall (2),
.BR futex (7)
.PP
\fIFuss, Futexes and Furwocks: Fast Userlevel Locking in Linux\fP
(proceedings of the Ottawa Linux Symposium 2002), online at
.br
.UR http://kernel.org\:/doc\:/ols\:/2002\:/ols2002-pages-479-495.pdf
.UE

\fIFutexes Are Tricky\fP (updated in 2011), Ulrich Drepper
.UR http://www.akkadia.org/drepper/futex.pdf
.UE
.PP
Futex example library, futex-*.tar.bz2 at
.br
.UR ftp://ftp.kernel.org\:/pub\:/linux\:/kernel\:/people\:/rusty/
.UE
